<html>

<head>
    <title>–∫—ã–∫ –±–ª&#127938;—Ç—å</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/static/style.css">
</head>

<body>
    <h1>–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ "–ö–´–ö"</h1>
    <h2>(<font color=red>–∫</font>—É–ª—å—Ç—É—Ä–Ω—ã–π <font color=red>—ãÃÅ</font>–º–∏–¥–∂ <font color=red>–ö</font>–∞—Ä–∏–º–∞)</h2>

    <p>–í —Ç–∞–±–ª–∏—á–∫–µ —Å–ø—Ä—è—Ç–∞–Ω—ã –Ω–µ—Å–∫–æ–ª—å–∫–æ —á–∏—Å—Ç–æ –∫–∞—Ä–∏–º–æ–≤—Å–∫–∏—Ö (–Ω–∞ –º–æ–π –≤–∑–≥–ª—è–¥) —Å–ª–æ–≤ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–π. –ö—Ç–æ –Ω–∞–π–¥—ë—Ç –±–æ–ª—å—à–µ? &#129312;</p>

    <h4>–°–æ–≤–µ—Ç—ã:</h4>

    <ul>
        <li>–°–ª–æ–≤–∞ –º–æ–≥—É—Ç –ø–µ—Ä–µ—Å–µ–∫–∞—Ç—å—Å—è (–ø—Ä–∏—á—ë–º –ø–æ—á—Ç–∏ —Ü–µ–ª–∏–∫–æ–º!) –∏ —Å–≥–∏–±–∞—Ç—å—Å—è.</li>
        <li>–°–ª–æ–≤–∞ –±—ã–ª–∏ —Å–æ–±—Ä–∞–Ω—ã –≤ –Ω–∞—á–∞–ª–µ 2020.</li>
        <li>–ó–∞–≥–∞–¥–∫–∞ 18+.</li>
        <li>–ü—Ä–æ—â–µ –≤—Å–µ–≥–æ –±—É–¥–µ—Ç —é–∂–Ω—ã–º –ø–∞—Ä–Ω—è–º.</li>
    </ul>

    <!-- Gray popup background -->
    <div id="popup-background" class="popup-background"></div>
    <!-- Popup image -->
    <div id="popup-content" class="popup-content">
        <img id="popup-image" class="popup-image">
    </div>

    <div id="table-wrapper">
        <table id="field" class="field">

        {% for row in field %}
            <tr>
            {% for letter in row %}
                <td onclick="addCellToCurrentWord(this, {x: {{forloop.parentloop.counter0}}, y: {{forloop.counter0}} })" class="blank">
                    <div class="field-cell">
                        <svg width=100% viewBox="0 0 25 25">
                          <text text-anchor="middle" x="12.5" y="18.5" class="cell-letter">{{ letter }}</text>
                        </svg>
                    </div>
                </td>
            {% endfor %}
            </tr>
        {% endfor %}
        </table>
    </div>

    <!-- Score counters -->
    <br>
    <table class="score-counters">
        <tr>
            <td>üßë‚Äçüéì —Å–ª–æ–≤: <span id="solved-main-words">0</span> –∏–∑ <span id="total-main-words">0</span></td>
            <td>ü§° —Å–ª–æ–≤: <span id="solved-extra-words">0</span></td>
        </tr>
    </table>

    <script>
        var currentWord = [];
        var currentSolvedCells = new Set();

        function fillCellElement(cellElement, newState) {
            for (let state of ['blank', 'inprogress', 'solved']) {
                if (cellElement.classList.replace(state, newState)) {
                    break;
                }
            }
        }

        function redrawField() {
            for (let cellElement of document.getElementById("field").getElementsByTagName("td")) {
                let x = cellElement.parentNode.rowIndex;
                let y = cellElement.cellIndex;

                var cellState;
                if (currentSolvedCells.has(x + "," + y)) {
                    cellState = 'solved';
                } else {
                    cellState = 'blank';
                }
                fillCellElement(cellElement, cellState);
            }
        }

        function clearState() {
            currentWord = [];
            redrawField();
        }

        function getSolvedWordsAndClearState() {
            const httpRequest = new XMLHttpRequest();
            httpRequest.open("GET", "state-query/");
            httpRequest.responseType = 'json';
            httpRequest.send();

            httpRequest.onload = (e) => {
                document.getElementById("total-main-words").innerHTML = String(httpRequest.response.total_main_words);
                document.getElementById("solved-main-words").innerHTML = String(httpRequest.response.solved_words.length);
                document.getElementById("solved-extra-words").innerHTML = String(httpRequest.response.solved_extra_words);

                for (let word of httpRequest.response.solved_words) {
                    var wordCell = word.start;

                    // dummy move, just for consistency of the below loop
                    word.order += 'r';

                    for (let move of word.order) {
                        currentSolvedCells.add(wordCell.x + "," + wordCell.y);

                        if (move == 'r') {
                            ++wordCell.y;
                        } else {
                            ++wordCell.x;
                        }
                    }
                }

                clearState();
            }
        }

        function checkIfCurrentWordIsANewSolvedWord() {
            // submit the new word and get true/false from server
            const httpRequest = new XMLHttpRequest();
            httpRequest.open("POST", "submit-word/");
            httpRequest.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
            httpRequest.responseType = 'json';

            httpRequest.send(JSON.stringify({'word': currentWord}));

            httpRequest.onload = (e) => {
                if (httpRequest.response.image) { // if the name of a static image to show isn't empty
                    document.getElementById("popup-image").src = '/' + httpRequest.response.image;
                    document.getElementById("popup-background").style.display = "block";
                    document.getElementById("popup-content")   .style.display = "block";
                    getSolvedWordsAndClearState();
                }
                // otherwise, the request was successful but the word isn't correct or isn't new; so don't clear `currentWord`
            }
        }

        function addCellToCurrentWord(newCellElement, newCell) {
            // Cancel move by clicking on 'body' but only OUTSIDE the table
            window.event.stopPropagation();

            function canBeANextLetterInWord(cellA, cellB) {
                const stepX = cellB.x - cellA.x;
                const stepY = cellB.y - cellA.y;
                return (stepX === 1 && stepY === 0) || (stepX === 0 && stepY === 1);
            }

            var isAValidMove = true;
            if (currentWord.length > 0 && !canBeANextLetterInWord(currentWord[currentWord.length - 1], newCell))
                isAValidMove = false;
            currentWord.forEach(function(cell) {
                if (cell.x == newCell.x && cell.y == newCell.y)
                    isAValidMove = false;
            });

            if (isAValidMove) {
                currentWord.push(newCell);
                fillCellElement(newCellElement, 'inprogress');
            }

            checkIfCurrentWordIsANewSolvedWord();
        }

        let popupBackground = document.getElementById("popup-background");
        let popupContent    = document.getElementById("popup-content");
        function hidePopupImage() {
            popupBackground.style.display = "none";
            popupContent   .style.display = "none";
        }
        popupBackground.addEventListener("click", hidePopupImage);
        popupContent   .addEventListener("click", hidePopupImage);

        document.getElementsByTagName('body')[0].onclick = clearState;
        document.onkeydown = function(e) { if (e.keyCode === 27) clearState(); }

        document.addEventListener('DOMContentLoaded', function(event) { getSolvedWordsAndClearState(); });
    </script>
</body>

</html>